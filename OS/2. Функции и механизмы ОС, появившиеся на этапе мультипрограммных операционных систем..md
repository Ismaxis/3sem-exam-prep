Программы становятся сложнее и разнообразнее. Появляется неэффективность, т.к. мы умеем выполнять программы только от начала до конца. У нас несколько программ загружено в память, но выполняется только одна, причем она почти никогда не использует одновременно все блоки и что-то простаивает (`IO` или `CPU`). 
### Обеспечение разделения времени процессов.
Количество потоков процессора всегда меньше количества процессов, решение этой проблемы - **псевдопараллельное** выполнение. Но как заставить процессор переключиться с одного процесса на другой?
1. Закладывать в программы места, где программа готова передать управление другому процессу. (работает плохо, однако сейчас `coroutine` в `Kotlin` сделаны похожим образом)
2. Сделать **таймер**, которые будет вызывать прерывание чтобы вызывать обработчик прерывания, который запустить планировщик. (Появляется необходимость сохранять и подгружать регистровый контекст при переключении процессов).
### Обеспечение разделения памяти.
Мы больше не знаем физические адреса, в которые будет загружены наша программа, поэтому появляется механизм виртуальной памяти.
### Обеспечение защиты программных данных от деятельности других программ.
В программах всегда будут ошибки и будет очень плохо если эта ошибка может навредить другим программам изменив их память. 
Необходимо уметь при обращении к памяти быстро определять свой/чужой. (Например на аппаратном уровне при помощи прерываний - `Access violation`). Но диспетчеру необходимо иметь доступ к чужой памяти. Поэтому появляется **привилегированный режим** - режим при котором отключаются проверки при обращении к памяти.
### Планирование выполнения программы и использования ресурсов.
Планирование стало сложнее. У каждого устройства появляется своя очередь, так ещё эти очереди связаны между собой. 
Использовать очень умные и сложные алгоритмы нельзя, т.к. тогда возрастает время переключения между процессами
Некоторые ресурсы неразделяемые (например печать на принтере), из-за чего могут возникать тупики при планировании. Если таких ресурсов 2 и каждый взят процессом, каждому из которых сейчас нужен второй ресурс вдобавок, то оба процесса ждут друг друга. `Deadlock`.
### Универсальный доступ к информации на внешних устройствах.
До этого, на внешних устройствах адресация была как у памяти, но теперь так неэффективно. Появляется файлово-каталожная система. 
**Файл** - некоторая совокупность данных, имеющая уникальное имя. **Каталог** - способ организации и хранения файлов.
### Обеспечение коммуникации между процессами.
Было бы классно передавать данные данные между программами. (Например `ctrl + c` и `ctrl + v` из одного окна в другое).
